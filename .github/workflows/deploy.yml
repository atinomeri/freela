name: Deploy

on:
  workflow_run:
    workflows: ["CI Fast"]
    types: [completed]
  workflow_dispatch:

concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Hostinger VPS
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.event == 'push' &&
       github.event.workflow_run.head_branch == 'main')
    environment:
      name: production
    permissions:
      contents: read
    env:
      VPS_HOST: ${{ secrets.VPS_HOST }}
      VPS_USER: ${{ secrets.VPS_USER }}
      VPS_PORT: ${{ secrets.VPS_SSH_PORT }}
      VPS_APP_DIR: ${{ secrets.VPS_APP_DIR }}
      SSH_PRIVATE_KEY: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
      VPS_HOST_KEY: ${{ secrets.VPS_HOST_KEY || '' }}
      DEPLOY_BRANCH: main
      DEPLOY_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
      HEALTHCHECK_URL: ${{ secrets.DEPLOY_HEALTHCHECK_URL }}
    steps:
      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in VPS_HOST VPS_USER VPS_PORT VPS_APP_DIR SSH_PRIVATE_KEY; do
            if [ -z "${!v}" ]; then
              echo "::error::Missing required secret: $v"
              exit 1
            fi
          done

      - name: Configure SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          if [ -n "$VPS_HOST_KEY" ]; then
            printf '%s\n' "$VPS_HOST_KEY" > ~/.ssh/known_hosts
          else
            echo "::warning::VPS_HOST_KEY is not set; using ssh-keyscan fallback."
            if ! ssh-keyscan -T 10 -p "$VPS_PORT" -H "$VPS_HOST" > ~/.ssh/known_hosts 2>/dev/null; then
              echo "::warning::ssh-keyscan failed; disabling strict host key checking."
              printf 'Host *\n  StrictHostKeyChecking no\n  UserKnownHostsFile /dev/null\n' > ~/.ssh/config
              chmod 600 ~/.ssh/config
            fi
          fi
          [ -f ~/.ssh/known_hosts ] && chmod 644 ~/.ssh/known_hosts || true

      - name: Deploy on server
        run: |
          set -euo pipefail
          ssh -p "$VPS_PORT" "$VPS_USER@$VPS_HOST" \
            "APP_DIR='$VPS_APP_DIR' BRANCH='$DEPLOY_BRANCH' EXPECTED_SHA='$DEPLOY_SHA' bash -s" <<'EOF'
          set -euo pipefail
          cd "$APP_DIR"
          echo "==> Repo: $(pwd)"
          echo "==> Origin: $(git remote get-url origin)"
          echo "==> Git status before pull:"
          git status --short || true

          # Force-sync to remote (handles CRLF diffs, stale index, local edits)
          git fetch origin "$BRANCH"
          git reset --hard "origin/$BRANCH"

          CURRENT_SHA="$(git rev-parse HEAD)"
          echo "==> Checked out SHA: $CURRENT_SHA"
          if [ -n "${EXPECTED_SHA:-}" ] && [ "$CURRENT_SHA" != "$EXPECTED_SHA" ]; then
            echo "::error::Deployed SHA mismatch. Expected $EXPECTED_SHA, got $CURRENT_SHA"
            exit 1
          fi
          cd deploy
          echo "==> Starting docker compose build & up..."
          docker compose -f docker-compose.prod.yml up -d --build

          # Wait for the app container to become healthy
          # (entrypoint runs migrations automatically before starting the server)
          echo "Waiting for app container to become healthy..."
          ATTEMPTS=0
          MAX_ATTEMPTS=40
          while [ "$ATTEMPTS" -lt "$MAX_ATTEMPTS" ]; do
            STATUS=$(docker inspect --format='{{.State.Health.Status}}' freela-app 2>/dev/null || echo "missing")
            echo "  attempt $((ATTEMPTS+1))/$MAX_ATTEMPTS - status: $STATUS"
            if [ "$STATUS" = "healthy" ]; then
              echo "App container is healthy!"
              break
            fi
            if [ "$STATUS" = "unhealthy" ]; then
              echo "::error::App container is unhealthy"
              docker compose -f docker-compose.prod.yml logs --tail=40 app
              exit 1
            fi
            ATTEMPTS=$((ATTEMPTS+1))
            sleep 5
          done
          if [ "$ATTEMPTS" -ge "$MAX_ATTEMPTS" ]; then
            echo "::error::Timed out waiting for app container health"
            docker compose -f docker-compose.prod.yml logs --tail=40 app
            exit 1
          fi
          EOF

      - name: Health check
        if: env.HEALTHCHECK_URL != ''
        run: |
          set -euo pipefail
          curl --fail --show-error --silent "$HEALTHCHECK_URL" > /dev/null
